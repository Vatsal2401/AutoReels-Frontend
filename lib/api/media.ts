import apiClient from "./client";

export type MediaStatus = "pending" | "processing" | "completed" | "failed";
export type StepStatus = "pending" | "processing" | "success" | "failed";
export type MediaType = "image" | "video" | "avatar" | "audio";
export type MediaAssetType = "script" | "audio" | "image" | "caption" | "video" | "avatar";

export interface MediaStep {
    id: string;
    media_id: string;
    step: string;
    status: StepStatus;
    depends_on: string[] | null;
    blob_storage_id: string | string[] | null;
    retry_count: number;
    error_message: string | null;
    started_at: string | null;
    completed_at: string | null;
    created_at: string;
    updated_at: string;
}

export interface MediaAsset {
    id: string;
    media_id: string;
    type: MediaAssetType;
    blob_storage_id: string;
    metadata: Record<string, any> | null;
    created_at: string;
    url?: string; // Signed URL generated by frontend transformation or backend
}

export interface Media {
    id: string;
    type: MediaType;
    flow_key: string;
    status: MediaStatus;
    user_id: string | null;
    input_config: Record<string, any> | null;
    blob_storage_id: string | null;
    error_message: string | null;
    script: string | null;
    created_at: string;
    updated_at: string;
    completed_at: string | null;
    steps?: MediaStep[];
    assets?: MediaAsset[];
    // Legacy compatibility fields if needed during transition
    final_url?: string;
    assets_by_type?: Record<string, any[]>;
    /** First image asset URL for card thumbnail */
    thumbnail_url?: string | null;
}

export interface EditorProjectDto {
    id: string;
    title: string;
    duration: string;
    script: string | null;
    audioUrl: string | null;
    captionUrl: string | null;
    imageUrls: string[];
    inputConfig: Record<string, any> | null;
    status: string;
    final_url?: string;
}

export interface CreateMediaDto {
    topic: string;
    type?: MediaType;
    flowKey?: string;
    language?: string;
    duration?: string;
    imageStyle?: string;
    imageAspectRatio?: string;
    voiceId?: string;
    imageProvider?: string;
    captions?: {
        enabled: boolean;
        preset: string;
        position: 'top' | 'bottom' | 'center';
        timing: 'sentence' | 'word';
    };
    music?: {
        id?: string;
        url?: string;
        name?: string;
        volume?: number;
    };
}

export const mediaApi = {
    createMedia: async (data: CreateMediaDto): Promise<Media> => {
        const response = await apiClient.post("/media", data);
        return response.data;
    },

    getAllMedia: async (): Promise<Media[]> => {
        const response = await apiClient.get("/media/user/me");
        return response.data;
    },

    getReelsPage: async (params: {
        limit?: number;
        cursor?: string | null;
    }): Promise<{ items: Media[]; nextCursor: string | null }> => {
        const searchParams = new URLSearchParams();
        if (params.limit != null) searchParams.set("limit", String(params.limit));
        if (params.cursor) searchParams.set("cursor", params.cursor);
        const response = await apiClient.get(
            `/media/user/me/list?${searchParams.toString()}`
        );
        return response.data;
    },

    getMedia: async (id: string): Promise<Media> => {
        const response = await apiClient.get(`/media/${id}`);
        return response.data;
    },

    getEditorProject: async (id: string): Promise<EditorProjectDto> => {
        const response = await apiClient.get(`/media/${id}/editor`);
        return response.data;
    },

    duplicateReel: async (id: string): Promise<Media> => {
        const response = await apiClient.post(`/media/${id}/duplicate`);
        return response.data;
    },

    deleteReel: async (id: string): Promise<void> => {
        await apiClient.delete(`/media/${id}`);
    },

    retryMedia: async (id: string): Promise<Media> => {
        const response = await apiClient.post(`/media/${id}/retry`);
        return response.data;
    },

    updateMedia: async (id: string, data: any): Promise<Media> => {
        const response = await apiClient.patch(`/media/${id}`, data);
        return response.data;
    },

    /**
     * Rerender: produce a new video from current or updated assets.
     * Use fromStep: "script" when script/topic changed; "render" when only options changed.
     * Backend returns 409 if media is currently processing.
     */
    rerenderMedia: async (
        id: string,
        options?: { fromStep?: "render" | "script" }
    ): Promise<Media> => {
        const response = await apiClient.post(`/media/${id}/rerender`, options ?? {});
        return response.data;
    },

    /**
     * Export as new version: creates a new media row (versioned), copies config/script, runs pipeline.
     * Returns the new media. Use for "Export video" in editor so each export is a new version.
     */
    exportAsVersion: async (id: string): Promise<Media> => {
        const response = await apiClient.post(`/media/${id}/export`);
        return response.data;
    },
};
